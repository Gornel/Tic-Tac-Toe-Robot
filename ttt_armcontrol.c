#pragma config(Sensor, S4,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Motor,  motorA,          arm1,          tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorC,          arm2,          tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorD,          pen,           tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//arm lengths
	//arm1 = 18 holes
	//arm2 = 16 and 1 holes
float L1=19;
float L2=14;

//More options
float inGearSize = 8;
float outGearSize = 40;
float gearRatio;

float arm1Target = 0;
float arm2Target = 0;



////////////////
//DECLARATIONS//
////////////////

//for calculating the multiple theta options
float c2;
float Part_1a;
float Part_1b;
float Part_2;
float Theta2_Option_A_rad;
float Theta2_Option_B_rad;
float theta2_rad;
float theta2_deg;
float k1;
float k2;
float theta1_rad;
float theta1_deg;

void calculateInstructions(float x, float y)
{
	gearRatio = (outGearSize/inGearSize);
	//adding 30 starts the calculation from zero?
		//calculate theta2
		c2 = (pow(x, 2) + pow(y, 2) - pow(L1, 2) - pow(L2, 2))/(2 * L1 * L2);
    Part_1a = sqrt(1 - pow(c2, 2));
    Part_1b = -sqrt(1 - pow(c2, 2));
    Part_2 =(c2);

    Theta2_Option_A_rad = atan2(Part_1a,Part_2);
    Theta2_Option_B_rad = atan2(Part_1b,Part_2);

    //use the theta2 option that has a smaller distance
    if (Theta2_Option_A_rad < Theta2_Option_B_rad){
       theta2_rad=atan2(Part_1a,Part_2);
      }
    else{
       theta2_rad=atan2(Part_1b,Part_2);
  		}

    theta2_deg = radiansToDegrees(theta2_rad);

    k1=L1+L2*cos(theta2_rad);
    k2=L2*sin(theta2_rad);

    //find theta1
    theta1_rad = atan2(y,x)-atan2(k2,k1);
    theta1_deg = radiansToDegrees(theta1_rad);

    ///////////////////////////////////////
    //update the arm targets with the new instructions
    ///////////////////////////////////////
    if (abs(theta1_deg) < 150){
    arm1Target = -theta1_deg;
  	}
  	else{
  		arm1Target = -theta1_deg + 360;
  		//playTone(10, 10);

  	}

		if (theta2_deg > 90){
		arm2Target = -theta2_deg + 360;
		}
		else{
			arm2Target = -theta2_deg;
		}
}

/////////////////////////////////
//MOVE THE ARMS TO GIVEN ANGELS//
////////////////////////////////

//ARM1
task moveArm1(){

float error;
float error_diff;
float speed;
float error_past;
float errorintg;
float current = 0;
float mostRecentTarget = 0;

float Kp = 5; //resolution control
float Kd = 0.1;//error correction
float Ki = 40;

while (true){
	if (mostRecentTarget != arm1Target)
	{
	error_diff = 0;
	speed = 0;
	error_past = 0;
	errorintg = 0;
	mostRecentTarget = arm1Target;
	error = 0;
	}

current = getMotorEncoder(arm1)/gearRatio;
error = arm1Target - current;
error_diff = (error - error_past)/0.01;
speed = (error*Kp + error_diff*Kd + errorintg*Ki);
error_past=error;
errorintg = (errorintg +  error)*0.01;
motor[arm1]= speed;
}
}

//ARM2
task moveArm2{

float error;
float error_diff;
float speed;
float error_past;
float errorintg;
float mostRecentTarget = 0;
float current = 0;

float Kp = 5; //resolution control
float Kd = 0.1;//error correction
float Ki = 40;

while (true){
	if (mostRecentTarget != arm2Target)
	{
	error = 0;
	error_diff = 0;
	speed = 0;
	error_past = 0;
	errorintg = 0;
	mostRecentTarget = arm2Target;
	}
current = getMotorEncoder(arm2)/gearRatio;
error = arm2Target - current;
error_diff = (error - error_past)/0.01;
speed = (error*Kp + error_diff*Kd + errorintg*Ki);
error_past=error;
errorintg = (errorintg +  error)*0.01;
motor[arm2]= speed;
}
}

//the arm tips starting coords are 30, 0. 30 is the maximum reach.
//x is along the arms starting axis, y is perpendicular
void goHome(){
	calculateInstructions(L1+L2, 0);
}


float xdest;
float ydest;
void translateCoords(float xcoord, float ycoord, bool scanmod){

	float ymod = 0;
	if (scanmod)
		ymod = 1;


	switch(xcoord){
		case 0: xdest = 12; break;//8//
		case 1: xdest = 19; break;//14
		case 2: xdest = 25; break;//19//
		case 3: xdest = 30; break;//24//
	}

	switch(ycoord){
		case 0: ydest = 10; break;//17//
		case 1: ydest = 4; break;//12//
		case 2: ydest = -2; break;//7//
		case 3: ydest = -7; break;//1//
	}

	if (xcoord == 0 && ycoord == 3)
	{
		xdest = 14;
		ydest = -7;
	}

		if (xcoord == 0 && ycoord == 2)
	{
		xdest = 13;
		ydest = -1;
	}

	if (xcoord == 0 && ycoord == 1)
	{
		xdest = 13;
		ydest = 5;
	}

	if (xcoord == 0 && ycoord == 0)
	{
		xdest = 12;
		ydest = 11;
	}

	if (xcoord == 1 && ycoord == 3)
	{
		xdest = 20;
		ydest = -6;
	}

	if (xcoord == 1 && ycoord == 2)
	{
		xdest = 20;
		ydest = 0;
	}

	if (xcoord == 1 && ycoord == 1)
	{
		xdest = 18;
		ydest = 5;
	}

	if (xcoord == 1 && ycoord == 0)
	{
		xdest = 18;
		ydest = 11;
	}

	if (xcoord == 2 && ycoord == 3)
	{
		xdest = 25;
		ydest = -8;
	}

	if (xcoord == 2 && ycoord == 2)
	{
		xdest = 25;
		ydest = -1;
	}

	if (xcoord == 2 && ycoord == 1)
	{
		xdest = 24.5;
		ydest = 5;
	}

	if (xcoord == 2 && ycoord == 0)
	{
		xdest = 23;
		ydest = 11;
	}

	if (xcoord == 3 && ycoord == 3)
	{
		xdest = 30;
		ydest = -11;
	}

	if (xcoord == 3 && ycoord == 2)
	{
		xdest = 31;
		ydest = -2;
	}

	if (xcoord == 3 && ycoord == 1)
	{
		xdest = 30;
		ydest = 4;
	}

	///////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////
	if (xcoord == 0.5 && ycoord == 0.5)
	{
		xdest = 16 - ymod;
		ydest = 7 - ymod*2;
	}

	if (xcoord == 0.5 && ycoord == 1.5)
	{
		xdest = 16;
		ydest = -1 + ymod;
	}

	if (xcoord == 0.5 && ycoord == 2.5)
	{
		xdest = 16;
		ydest = -5 - ymod;
	}

	if (xcoord == 1.5 && ycoord == 0.5)
	{
		xdest = 22 + ymod;
		ydest = 4 + ymod;
	}

	if (xcoord == 1.5 && ycoord == 1.5)
	{
		xdest = 22;
		ydest = 0;
	}

	if (xcoord == 1.5 && ycoord == 2.5)
	{
		xdest = 22;
		ydest = -6 - ymod;
	}

	if (xcoord == 2.5 && ycoord == 0.5)
	{
		xdest = 29;
		ydest = 5 - ymod*7;
	}

	if (xcoord == 2.5 && ycoord == 1.5)
	{
		xdest = 29 - ymod;
		ydest = -2 - ymod*6;
	}

	if (xcoord == 2.5 && ycoord == 2.5)
	{
		xdest = 29 - ymod*1;
		ydest = -9 - ymod*2;
	}

}

void Goto(float xcoord, float ycoord, bool scanmod){
	//seperating movement from translation function for other uses
	translateCoords(xcoord, ycoord, scanmod);
	//move to coords
	calculateInstructions(xdest, ydest);
	sleep(1000);
}

bool scanForRed(){
	int color = SensorValue[colorSensor];
	if ( color == 5){
		playTone(10, 10);
		return true;
	}
	else
		return false;
}


void activatePen(){
	sleep(500);
	setMotorTarget(pen, -200, 10);
	sleep(2000);
}

void deactivatePen(){
	sleep(1000);
	setMotorTarget(pen, 0, 100);
	sleep(1000);
}


void x00(){

	xdest = 16;
	ydest = 7;

	//first stroke
	//xdest -= 1;
	ydest -= 1;
	calculateInstructions(xdest, ydest);
	activatePen();
	xdest += 4;
	ydest += 5;
	calculateInstructions(xdest, ydest);
	deactivatePen();
	//goHome();

	//second stroke
	ydest -= 8;
	//xdest -= 3;
	calculateInstructions(xdest, ydest);
	activatePen();
	xdest -= 6;
	ydest += 10;
	calculateInstructions(xdest, ydest);
	sleep(1000);
	//xdest -= 2;
	//ydest += 4;
	//calculateInstructions(xdest, ydest);
	deactivatePen();
	goHome();
}

void x10(){
	xdest = 22;
	ydest = 4;
	//first stroke
	xdest -= 1;
	ydest -= 0;
	calculateInstructions(xdest, ydest);
	activatePen();
	xdest += 4;
	ydest += 5;
	calculateInstructions(xdest, ydest);
	deactivatePen();
	//goHome();

	//second stroke
	ydest -= 9;
	xdest -= 0;
	calculateInstructions(xdest, ydest);
	activatePen();
	xdest -= 3;
	ydest += 13;
	calculateInstructions(xdest, ydest);
	sleep(1000);
	//xdest -= 2;
	//ydest += 4;
	//calculateInstructions(xdest, ydest);
	deactivatePen();
	goHome();
}
void x20(){
	xdest = 29;
	ydest = 5;

	//first stroke
	xdest -= 2;
	ydest -= 0;
	calculateInstructions(xdest, ydest);
	activatePen();
	xdest += 3;
	ydest += 5;
	calculateInstructions(xdest, ydest);
	deactivatePen();
	//goHome();

	//second stroke
	ydest -= 9;
	xdest += 1;
	calculateInstructions(xdest, ydest);
	activatePen();
	xdest -= 5;
	ydest += 13;
	calculateInstructions(xdest, ydest);
	sleep(1000);
	//xdest -= 2;
	//ydest += 4;
	//calculateInstructions(xdest, ydest);
	deactivatePen();
	goHome();
}
void x01(){
	xdest = 16;
	ydest = -1;

	//first stroke
	xdest -= 0;
	ydest -= 0;
	calculateInstructions(xdest, ydest);
	activatePen();
	xdest += 3;
	ydest += 7;
	calculateInstructions(xdest, ydest);
	deactivatePen();
	//goHome();

	//second stroke
	ydest -= 9;
	//xdest -= 3;
	calculateInstructions(xdest, ydest);
	activatePen();
	xdest -= 3;
	ydest += 7;
	calculateInstructions(xdest, ydest);
	sleep(1000);
	//xdest -= 2;
	//ydest += 4;
	//calculateInstructions(xdest, ydest);
	deactivatePen();
	goHome();
}
void x11(){
	xdest = 22;
	ydest = 0;

	//first stroke
	xdest -= 0;
	ydest -= 1;
	calculateInstructions(xdest, ydest);
	activatePen();
	xdest += 4;
	ydest += 6;
	calculateInstructions(xdest, ydest);
	deactivatePen();
	//goHome();

	//second stroke
	ydest -= 11;
	xdest += 1;
	calculateInstructions(xdest, ydest);
	activatePen();
	xdest -= 3;
	ydest += 13;
	calculateInstructions(xdest, ydest);
	sleep(1000);
	//xdest -= 2;
	//ydest += 4;
	//calculateInstructions(xdest, ydest);
	deactivatePen();
	goHome();
}
void x21(){
	xdest = 29;
	ydest = -2;

	//first stroke
	xdest -= 1;
	ydest -= 0;
	calculateInstructions(xdest, ydest);
	activatePen();
	xdest += 3;
	ydest += 7;
	calculateInstructions(xdest, ydest);
	deactivatePen();
	//goHome();

	//second stroke
	ydest -= 11;
	//xdest -= 3;
	calculateInstructions(xdest, ydest);
	activatePen();
	xdest -= 3;
	ydest += 13;
	calculateInstructions(xdest, ydest);
	sleep(1000);
	//xdest -= 2;
	//ydest += 4;
	//calculateInstructions(xdest, ydest);
	deactivatePen();
	goHome();
}

void x02(){
	xdest = 16;
	ydest = -5;

	//first stroke
	xdest += 1;
	ydest -= 1;
	calculateInstructions(xdest, ydest);
	activatePen();
	xdest += 4;
	ydest += 7;
	calculateInstructions(xdest, ydest);
	deactivatePen();
	//goHome();

	//second stroke
	ydest -= 11;
	xdest -= 1;
	calculateInstructions(xdest, ydest);
	activatePen();
	xdest -= 1;
	ydest += 10;
	calculateInstructions(xdest, ydest);
	sleep(1000);
	//xdest -= 2;
	//ydest += 4;
	//calculateInstructions(xdest, ydest);
	deactivatePen();
	goHome();
}
void x12(){
	xdest = 22;
	ydest = -6;

	//first stroke
	xdest += 1;
	ydest -= 0;
	calculateInstructions(xdest, ydest);
	activatePen();
	xdest += 4;
	ydest += 8;
	calculateInstructions(xdest, ydest);
	deactivatePen();
	//goHome();

	//second stroke
	ydest -= 13;
	xdest -= 1;
	calculateInstructions(xdest, ydest);
	activatePen();
	xdest -= 2;
	ydest += 9;
	calculateInstructions(xdest, ydest);
	sleep(1000);
	//xdest -= 2;
	//ydest += 4;
	//calculateInstructions(xdest, ydest);
	deactivatePen();
	goHome();
}
void x22(){
	xdest = 29;
	ydest = -9;

	//first stroke
	xdest -= 2;
	ydest -= 1;
	calculateInstructions(xdest, ydest);
	activatePen();
	xdest += 4;
	ydest += 5;
	calculateInstructions(xdest, ydest);
	deactivatePen();
	//goHome();

	//second stroke
	ydest = -15;
	xdest = 29;
	calculateInstructions(xdest, ydest);
	activatePen();
	xdest += 1;
	ydest += 13;
	calculateInstructions(xdest, ydest);
	sleep(1000);
	//xdest -= 2;
	//ydest += 4;
	//calculateInstructions(xdest, ydest);
	deactivatePen();
	goHome();
}
void drawXat(float x, float y){
	goHome();
	sleep(1000);
	if(x == 0 && y == 0)
		x00();
	else if(x == 1 && y == 0)
		x10();
	else if(x == 2 && y == 0)
		x20();
	else if(x == 0 && y == 1)
		x01();
	else if(x == 1 && y == 1)
		x11();
	else if(x == 2 && y == 1)
		x21();
	else if(x == 0 && y == 2)
		x02();
	else if(x == 1 && y == 2)
		x12();
	else if(x == 2 && y == 2)
		x22();
}

/*
task main()
{

		//SETUP:
	//SHINE LIGHT ON 3, 2
	//////////////////////////////////////////////////////
	resetMotorEncoder(arm1);
	resetMotorEncoder(arm2);
	//sets the starting point where the arm is
	goHome();
	startTask (moveArm1);
	startTask (moveArm2);
	//goHome();
	drawXat(1,1);
//activatePen();
//deactivatePen();
//scan();
sleep(100000);
}*/
